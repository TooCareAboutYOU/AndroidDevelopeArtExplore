    /**               Thready与Runnableq区别
     *
     * 如果一个类继承Thread,则不适合资源共享，若实现Runnable接口，则很容易显示资源共享
     * 实现Runnable接口比继承Thread类更具有优势：
     *    1、适合多个相同的程序代码的线程去处理同一个资源
     *    2、可以避免java中的单继承的限制
     *    3、增在程序的健壮性，代码可以被多个线程共享，代买阿和数据独立
     */
     
     
     
     /*======================================================================================*/
    /**                       线程切换状态
     *
     * 1、新建状态(New):新创建了一个线程对象。
     * 2、就绪状态(Runnable):线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行， 等待获取CPU的使用权。
     * 3、运行状态(Running):就绪状态的线程获取了CPU，执行程序代码。
     * 4、阻塞状态(Blocked):阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种:
     *    (一)、等待阻塞:运行的线程执行wait()方法，JVM会把该线程放入等待池中。
     *    (二)、同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
     *    (三)、其他阻塞:运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、 join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
     * 5、死亡状态(Dead):线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
     */
     
     
     
     /*======================================================================================*/
    /**                       线程调度
     *
     * 1、调整线程优先级:Java线程有优先级，优先级高的线程会获得较多的运行机会。
     *    Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量:
     *         static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。
     *         static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。
     *         static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。
     *     Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
     *     每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
     *     线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
     *     JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有
     *     以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。
     *
     * 2、线程睡眠:Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。
     *    当睡眠结束后，就转为 就绪(Runnable)状态。sleep()平台移植性好。
     *
     * 3、程等待:Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。
     *    这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。
     *
     * 4、线程让步:Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
     *
     * 5、线程加入:join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运
     *    行结束，当前线程再由阻塞转为就绪状态。
     *
     * 6、线程唤醒:Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中 一
     *    个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程 放弃
     *    此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争;例如， 唤醒的线
     *    程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所 有线程。
     *    注意:Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。
     *
     */
     
     
     
     
     /*======================================================================================*/
    /**               sleep()和yield()的区别
     * 
     * sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行;
     * yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。
     * 
     * sleep方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，
     * yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。
     * 
     * yield()方法对应了如下操作：
     *      先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。
     *      所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程
     * sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，
     * 所以，不可能让出较低优先级的线程些时获得 CPU 占有权。
     * 
     * 在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。
     */
     
     
     
     /*======================================================================================*/

    /** interrupt():
     * 中断某个线程，这种结束方式比较粗暴， 
     * 如果t线程打开了某个资源还没来得及关闭也就是run方法还没有执行完就强制结束线程，
     * 会导致资源无法关闭 要想结束进程最好的办法就是用sleep()函数的例子程序里那样，
     * 在线程类里面用以个boolean型变量来控制run()方法什么时候结 束，run()方法一结束，该线程也就结束了。
     */
     
     
     
      /*======================================================================================*/

     /**                 Obj.wait()
      *
      * Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，
      * 从语法角度来说 就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，
      * 主动释放对象锁，同时本 线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。
      * 相应的notify()就是对对象锁的唤醒操作。 但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，
      * 而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM 会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，
      * 唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。 Thread.sleep()与Object.wait()二者都可以暂停当前线程，
      * 释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁 的控制。
      */
      
      
      
      /*======================================================================================*/
      
      /**               wait和sleep区别
       *
       * 一、共同点：
       *     1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。
       *     2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。
       *        如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。
       *        如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch(){}中直接return即可安全地结束线程。
       *        注：InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该
       *        线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，
       *        就会立刻抛出InterruptedException 。
       *
       * 二、不同点
       *     1、Thread类的方法:sleep(),yield()等 Object的方法:wait()和notify()等
       *     2、每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。
       *        sleep()没有释放锁，而wait()释放了锁，使得其他线程可以使用同步控制块或者方法。
       *     3、wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
       *     4、sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 所以sleep()和wait()方法的最大区别是:
       *        sleep()睡眠时，保持对象锁，仍然占有该锁;而wait()睡眠时，释放对象锁。 但是wait()和sleep()都可以通过
       *        interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException(但不建议使用该方 法)。
       *
       * sleep()使当前线程进入停滞状态(阻塞当前线程)，让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，
       *  以留一定时间给其他线程执行的机会;sleep()是Thread类的Static(静态)的方法;因此他不能改变对象的机锁，所以当在一个Synchronized块中
       *  调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象(即使睡着也持有对象锁)。
       *  new Thread(pb).start();在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有 更高的优先级。
       *
       * wait()方法是Object类里的方法;当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去(释放)了对象的
       *  机锁(暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁);其他线程可以访问; wait()使用notify或者notifyAlll或者指定睡眠时间来
       *  唤醒当前等待池中的线程。wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。
       *
       */
       
       
       
       /*======================================================================================*/
       /**           线程同步 synchronized
        *
        * 一、作用域：
        *     1、是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法(如果一个对象有多个synchronized方法，
        *        只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法)。
        *        这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized 方法;
        *     2、是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对 象实例起作用。
        * 二、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法 是: synchronized(this){/区块/}，它的作用域是当前对象;
        * 三、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}
        *     而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法;
        *      A.无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。
        *      B.每个对象只有一个锁(lock)与之相关联。 C.实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。
        *
        * 四、
        *    1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。
        *    2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，
        *       其他访问该对象的线程就无法再访问该对象的其他非同步方法。
        *    3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，
        *       当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。
        *    4、对于同步，要时刻清醒在哪个对象上同步，这是关键。
        *    5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，
        *       并保证原子操作期间别的线程无法访问竞争资源。
        *    6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。
        *    7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。但是，一旦程序发生死锁，程序将死掉。
        */